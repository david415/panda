package panda

import (
	"bytes"
	"crypto/sha256"
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
	"strings"
	"sync"

	"github.com/david415/panda/rijndael"
	"github.com/ugorji/go/codec"
	"golang.org/x/crypto/argon2"
	"golang.org/x/crypto/curve25519"
	"golang.org/x/crypto/hkdf"
	"golang.org/x/crypto/nacl/secretbox"
)

const (
	generatedSecretStringPrefix = "r!"
	// generatedSecretStringPrefix2 is used to indicate that the KDF should
	// be skipped because the generated secret is sufficiently random.
	// These strings are not output, yet, but they are handled. In the
	// future, the code will start outputting them - although this will
	// (silently, painfully) break clients that are too old to support
	// them.
	generatedSecretStringPrefix2 = "r["

	keyExchangeStatusInit      = 0
	keyExchangeStatusExchange1 = 1
	keyExchangeStatusExchange2 = 2
)

var jsonHandle *codec.JsonHandle

// NewSecretString generates a random, human readable string with a special
// form that includes a checksum which allows typos to be rejected (so long as
// the typo isn't in the first two letters).
func NewSecretString(rand io.Reader) (string, error) {
	b := make([]byte, 16, 18)
	if _, err := rand.Read(b); err != nil {
		return "", fmt.Errorf("error reading from rand: " + err.Error())
	}

	// The use of SHA-256 is overkill, but we already use SHA-256 so it's
	// more parsimonious than importing a more suitable hash function.
	h := sha256.New()
	h.Write(b)
	digest := h.Sum(nil)

	b = append(b, digest[0], digest[1])
	return generatedSecretStringPrefix + hex.EncodeToString(b), nil
}

// isValidSecretString returns true if s is of the form generated by
// NewSecretString.
func isValidSecretString(s string) bool {
	if !strings.HasPrefix(s, generatedSecretStringPrefix) &&
		!strings.HasPrefix(s, generatedSecretStringPrefix2) {
		return false
	}
	s = s[len(generatedSecretStringPrefix):]

	var b [18]byte
	if len(s)%2 == 1 || hex.DecodedLen(len(s)) != len(b) {
		return false
	}
	if _, err := hex.Decode(b[:], []byte(s)); err != nil {
		return false
	}

	h := sha256.New()
	h.Write(b[:16])
	digest := h.Sum(nil)

	return b[16] == digest[0] && b[17] == digest[1]
}

// IsAcceptableSecretString returns true if s should be accepted as a secret
// string. The only strings that will be rejected are those that start with
// generatedSecretStringPrefix but don't have a matching checksum.
func IsAcceptableSecretString(s string) bool {
	if !strings.HasPrefix(s, generatedSecretStringPrefix) &&
		!strings.HasPrefix(s, generatedSecretStringPrefix2) {
		return true
	}

	return isValidSecretString(s)
}

var ShutdownErr = errors.New("panda: shutdown requested")

type MeetingPlace interface {
	Padding() int
	Exchange(log func(string, ...interface{}), id, message []byte, shutdown chan struct{}) ([]byte, error)
}

type KeyExchange struct {
	sync.Mutex

	Log          func(string, ...interface{})
	Testing      bool
	ShutdownChan chan struct{}

	rand         io.Reader
	status       int
	meetingPlace MeetingPlace
	sharedSecret []byte
	serialised   []byte
	kxBytes      []byte

	key, meeting1, meeting2 [32]byte
	dhPublic, dhPrivate     [32]byte
	sharedKey               [32]byte
	message1, message2      []byte
}

func NewKeyExchange(rand io.Reader, meetingPlace MeetingPlace, sharedSecret []byte, kxBytes []byte) (*KeyExchange, error) {
	if 24 /* nonce */ +4 /* length */ +len(kxBytes)+secretbox.Overhead > meetingPlace.Padding() {
		return nil, errors.New("panda: key exchange too large for meeting place")
	}

	kx := &KeyExchange{
		Log:          func(format string, args ...interface{}) {},
		rand:         rand,
		meetingPlace: meetingPlace,
		status:       keyExchangeStatusInit,
		sharedSecret: sharedSecret,
		kxBytes:      kxBytes,
	}

	if _, err := io.ReadFull(kx.rand, kx.dhPrivate[:]); err != nil {
		return nil, err
	}
	curve25519.ScalarBaseMult(&kx.dhPublic, &kx.dhPrivate)
	err := kx.updateSerialised()
	if err != nil {
		return nil, err
	}

	return kx, nil
}

type KeyExchangeJSON struct {
	status                  int
	sharedSecret            []byte
	serialised              []byte
	kxBytes                 []byte
	key, meeting1, meeting2 [32]byte
	dhPublic, dhPrivate     [32]byte
	sharedKey               [32]byte
	message1, message2      []byte
}

func UnmarshalKeyExchange(rand io.Reader, meetingPlace MeetingPlace, serialised []byte) (*KeyExchange, error) {
	kxj := new(KeyExchangeJSON)
	dec := codec.NewDecoderBytes(bytes.TrimRight(serialised, "\x00"), jsonHandle)
	if err := dec.Decode(kxj); err != nil {
		return nil, err
	}
	kx := &KeyExchange{
		status:       kxj.status,
		sharedSecret: kxj.sharedSecret,
		kxBytes:      kxj.kxBytes,
		key:          kxj.key,
		meeting1:     kxj.meeting1,
		meeting2:     kxj.meeting2,
		dhPublic:     kxj.dhPublic,
		dhPrivate:    kxj.dhPrivate,
		sharedKey:    kxj.sharedKey,
		message1:     kxj.message1,
		message2:     kxj.message2,
	}
	curve25519.ScalarBaseMult(&kx.dhPublic, &kx.dhPrivate)
	return kx, nil
}

func (kx *KeyExchange) Marshal() []byte {
	kx.Lock()
	defer kx.Unlock()
	return kx.serialised
}

func (kx *KeyExchange) updateSerialised() error {
	serialised := make([]byte, 0)
	enc := codec.NewEncoderBytes(&serialised, jsonHandle)
	kxj := &KeyExchangeJSON{
		status:       kx.status,
		sharedSecret: kx.sharedSecret,
		kxBytes:      kx.kxBytes,
		key:          kx.key,
		meeting1:     kx.meeting1,
		meeting2:     kx.meeting2,
		dhPublic:     kx.dhPublic,
		dhPrivate:    kx.dhPrivate,
		sharedKey:    kx.sharedKey,
		message1:     kx.message1,
		message2:     kx.message2,
	}
	err := enc.Encode(kxj)
	if err != nil {
		return err
	}
	kx.Lock()
	defer kx.Unlock()
	kx.serialised = serialised
	return nil
}

func (kx *KeyExchange) shouldStop() bool {
	select {
	case <-kx.ShutdownChan:
		return true
	default:
		return false
	}

	// unreachable
}

func (kx *KeyExchange) Run() ([]byte, error) {
	switch kx.status {
	case keyExchangeStatusInit:
		if err := kx.derivePassword(); err != nil {
			return nil, err
		}
		kx.status = keyExchangeStatusExchange1
		err := kx.updateSerialised()
		if err != nil {
			return nil, err
		}
		kx.Log("password derivation complete.")
		if kx.shouldStop() {
			return nil, ShutdownErr
		}
		fallthrough
	case keyExchangeStatusExchange1:
		if err := kx.exchange1(); err != nil {
			return nil, err
		}
		kx.status = keyExchangeStatusExchange2
		err := kx.updateSerialised()
		if err != nil {
			return nil, err
		}
		kx.Log("first message exchange complete")
		if kx.shouldStop() {
			return nil, ShutdownErr
		}
		fallthrough
	case keyExchangeStatusExchange2:
		reply, err := kx.exchange2()
		if err != nil {
			return nil, err
		}
		return reply, nil
	default:
		return nil, errors.New("unknown state")
	}

	// unreachable
}

func (kx *KeyExchange) derivePassword() error {
	if kx.Testing {
		h := hkdf.New(sha256.New, kx.sharedSecret, nil, []byte("PANDA strong secret expansion"))
		if _, err := h.Read(kx.key[:]); err != nil {
			return err
		}
		if _, err := h.Read(kx.meeting1[:]); err != nil {
			return err
		}
		if _, err := h.Read(kx.meeting2[:]); err != nil {
			return err
		}
	} else {
		data := argon2.Key(kx.sharedSecret, nil, 3, 32*1024, 4, 32*3)
		copy(kx.key[:], data)
		copy(kx.meeting1[:], data[32:])
		copy(kx.meeting2[:], data[64:])
	}

	var encryptedDHPublic [32]byte
	rijndael.NewCipher(&kx.key).Encrypt(&encryptedDHPublic, &kx.dhPublic)

	l := len(encryptedDHPublic)
	if padding := kx.meetingPlace.Padding(); l > padding {
		return errors.New("panda: initial message too large for meeting place")
	} else if l < padding {
		l = padding
	}

	kx.message1 = make([]byte, l)
	copy(kx.message1, encryptedDHPublic[:])
	if _, err := io.ReadFull(kx.rand, kx.message1[len(encryptedDHPublic):]); err != nil {
		return err
	}

	return nil
}

func (kx *KeyExchange) exchange1() error {
	reply, err := kx.meetingPlace.Exchange(kx.Log, kx.meeting1[:], kx.message1[:], kx.ShutdownChan)
	if err != nil {
		return err
	}

	var peerDHPublic, encryptedPeerDHPublic [32]byte
	if len(reply) < len(encryptedPeerDHPublic) {
		return errors.New("panda: meeting point reply too small")
	}

	copy(encryptedPeerDHPublic[:], reply)
	rijndael.NewCipher(&kx.key).Decrypt(&peerDHPublic, &encryptedPeerDHPublic)

	curve25519.ScalarMult(&kx.sharedKey, &kx.dhPrivate, &peerDHPublic)

	paddedLen := kx.meetingPlace.Padding()
	padded := make([]byte, paddedLen-24 /* nonce */ -secretbox.Overhead)
	binary.LittleEndian.PutUint32(padded, uint32(len(kx.kxBytes)))
	copy(padded[4:], kx.kxBytes)
	if _, err := io.ReadFull(kx.rand, padded[4+len(kx.kxBytes):]); err != nil {
		return err
	}

	var nonce [24]byte
	if _, err := io.ReadFull(kx.rand, nonce[:]); err != nil {
		return err
	}

	kx.message2 = make([]byte, paddedLen)
	copy(kx.message2, nonce[:])
	secretbox.Seal(kx.message2[24:24], padded, &nonce, &kx.sharedKey)

	return nil
}

func (kx *KeyExchange) exchange2() ([]byte, error) {
	reply, err := kx.meetingPlace.Exchange(kx.Log, kx.meeting2[:], kx.message2[:], kx.ShutdownChan)
	if err != nil {
		return nil, err
	}

	var nonce [24]byte
	if len(reply) < len(nonce) {
		return nil, errors.New("panda: meeting point reply too small")
	}

	if kx.sharedKey[0] == 0 && kx.sharedKey[1] == 0 {
		return nil, errors.New("exchange2 failure, shared keys are zero")
	}
	copy(nonce[:], reply)
	message, ok := secretbox.Open(nil, reply[24:], &nonce, &kx.sharedKey)
	if !ok {
		return nil, errors.New("panda: peer's message cannot be authenticated")
	}

	if len(message) < 4 {
		return nil, errors.New("panda: peer's message is invalid")
	}
	l := binary.LittleEndian.Uint32(message)
	message = message[4:]
	if l > uint32(len(message)) {
		return nil, errors.New("panda: peer's message is truncated")
	}
	message = message[:int(l)]
	return message, nil
}

func init() {
	jsonHandle = new(codec.JsonHandle)
	jsonHandle.Canonical = true
}
